<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dance4WhatEver</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="icon" href="./icon48.png" type="image/png">
    <style></style>
  </head>
  <body>
    <div style="flex: 1">
      <div class="comparison-container">
        <!-- 参考视频 -->
        <div class="video-section">
          <div class="progress-container">
            <span class="time-display" id="referenceCurrentTime">00:00</span>
            <input
              type="range"
              id="referenceProgressBar"
              class="progress-bar"
              value="0"
              min="0"
              max="100"
            />
            <span class="time-display" id="referenceTotalTime">00:00</span>
          </div>
          <div class="video-wrapper">
            <video id="referenceVideo" playsinline></video>
            <canvas id="referenceCanvas"></canvas>
          </div>
          <div class="controls-group">
            <button id="referencePlayButton" disabled>播放</button>
            <button id="referencePauseButton" disabled>暂停</button>
            <!-- <button id="referenceAnalyzeButton" disabled>开始分析</button> -->
          </div>
          <div class="angle-data">
            <h4>关键点角度数据</h4>
            <div id="referenceAngleData">等待分析...</div>
          </div>
          <div class="file-input-group">
            <input type="file" id="referenceFileInput" accept="video/*, .flv" />
            <button id="loadReferenceButton">加载参考视频</button>
          </div>
        </div>

        <!-- 对比视频 -->
        <div class="video-section">
          <div class="progress-container">
            <span class="time-display" id="targetCurrentTime">00:00</span>
            <input
              type="range"
              id="targetProgressBar"
              class="progress-bar"
              value="0"
              min="0"
              max="100"
            />
            <span class="time-display" id="targetTotalTime">00:00</span>
          </div>

          <div class="video-wrapper">
            <video id="targetVideo" playsinline></video>
            <canvas id="targetCanvas"></canvas>
          </div>
          <div class="controls-group">
            <button id="targetPlayButton" disabled>播放</button>
            <button id="targetPauseButton" disabled>暂停</button>
            <!-- <button id="targetAnalyzeButton" disabled>开始分析</button> -->
          </div>
          <div class="angle-data">
            <h4>关键点角度数据</h4>
            <div id="targetAngleData">等待分析...</div>
          </div>
          <div class="file-input-group">
            <input type="file" id="targetFileInput" accept="video/*, .flv" />
            <button id="loadTargetButton">加载对比视频</button>
            <button id="useCameraButton">使用摄像头</button>
            <button id="stopCameraButton" disabled>停止摄像头</button>
          </div>
        </div>

        <!-- 相似度结果 -->
      </div>
    </div>

    <div id="dataPanel">
      <div class="similarity-container">
        <!-- 添加上半身、下半身和窗口相似度显示 -->
        <div class="detailed-similarity">
          <h3>详细相似度分析</h3>
          <div class="similarity-item">
            <span class="similarity-label">上半身瞬间相似度:</span>
            <span class="similarity-value" id="upperBodyInstantSimilarity"
              >--%</span
            >
          </div>
          <div class="similarity-item">
            <span class="similarity-label">下半身瞬间相似度:</span>
            <span class="similarity-value" id="lowerBodyInstantSimilarity"
              >--%</span
            >
          </div>
          <div class="similarity-item">
            <span class="similarity-label">窗口相似度:</span>
            <span class="similarity-value" id="windowSimilarity">--%</span>
          </div>
        </div>

        <div id="similarityStatus">请加载两个视频并开始分析</div>
        <div class="controls-group">
          <button id="startComparisonButton" disabled>开始比较</button>
          <button id="stopComparisonButton" disabled>停止比较</button>
        </div>

        <div class="angle-data">
          <h4>角度差异对比</h4>
          <div id="comparisonAngleData">等待比较...</div>
        </div>

        <!-- <div class="angle-data">
                    <h4>各肢体相似度</h4>
                    <div id="limbSimilarityData">等待比较...</div>
                </div> -->
      </div>
      <div id="keypointsComparison" class="panel-section">
        <h3>关键点对比数据</h3>
        <div id="comparisonData"></div>
      </div>
    </div>

    <script src="./models/tf.min.js"></script>
    <script src="./models/pose-detection.min.js"></script>
    <script>
      // 页面元素
      const referenceFileInput = document.getElementById("referenceFileInput");
      const loadReferenceButton = document.getElementById(
        "loadReferenceButton"
      );
      const referenceVideo = document.getElementById("referenceVideo");
      const referenceCanvas = document.getElementById("referenceCanvas");
      const referenceCtx = referenceCanvas.getContext("2d");
      const referencePlayButton = document.getElementById(
        "referencePlayButton"
      );
      const referencePauseButton = document.getElementById(
        "referencePauseButton"
      );
      const referenceAnalyzeButton = document.getElementById(
        "referenceAnalyzeButton"
      );
      const referenceCurrentTime = document.getElementById(
        "referenceCurrentTime"
      );
      const referenceTotalTime = document.getElementById("referenceTotalTime");
      const referenceProgressBar = document.getElementById(
        "referenceProgressBar"
      );
      const referenceAngleData = document.getElementById("referenceAngleData");

      const targetFileInput = document.getElementById("targetFileInput");
      const loadTargetButton = document.getElementById("loadTargetButton");
      const useCameraButton = document.getElementById("useCameraButton");
      const stopCameraButton = document.getElementById("stopCameraButton");
      const targetVideo = document.getElementById("targetVideo");
      const targetCanvas = document.getElementById("targetCanvas");
      const targetCtx = targetCanvas.getContext("2d");
      const targetPlayButton = document.getElementById("targetPlayButton");
      const targetPauseButton = document.getElementById("targetPauseButton");
      const targetAnalyzeButton = document.getElementById(
        "targetAnalyzeButton"
      );
      const targetCurrentTime = document.getElementById("targetCurrentTime");
      const targetTotalTime = document.getElementById("targetTotalTime");
      const targetProgressBar = document.getElementById("targetProgressBar");
      const targetAngleData = document.getElementById("targetAngleData");

      // 摄像头相关变量
      let cameraStream = null;

      // 模型相关变量
      let referencePoseDetector = null;
      let targetPoseDetector = null;

      // 视频状态变量
      let referenceLoaded = false;
      let targetLoaded = false;
      let comparisonRunning = false;

      // 帧缓存用于一秒内的上下文比较
      let referenceFrameBuffer = [];
      let targetFrameBuffer = [];
      let currentSecond = -1;

      // 上一次关键点缓存，用于处理置信度不足的情况
      let lastReferenceKeypoints = {};
      let lastTargetKeypoints = {};

      // 滑动窗口参数
      const WINDOW_SIZE = 5; // 窗口大小（帧数）

      // 上一次角度缓存，用于处理角度丢失的情况
      let lastReferenceAngles = {};
      let lastTargetAngles = {};

      // 关键点定义（排除脸部关键点）
      const KEYPOINT_NAMES = [
        "nose", // 0
        "left_eye", // 1
        "right_eye", // 2
        "left_ear", // 3
        "right_ear", // 4
        "left_shoulder", // 5
        "right_shoulder", // 6
        "left_elbow", // 7
        "right_elbow", // 8
        "left_wrist", // 9
        "right_wrist", // 10
        "left_hip", // 11
        "right_hip", // 12
        "left_knee", // 13
        "right_knee", // 14
        "left_ankle", // 15
        "right_ankle", // 16
      ];

      // 定义关键点的父子关系（排除脸部关键点）
      const KEYPOINT_PARENTS = {
        left_elbow: "left_shoulder",
        right_elbow: "right_shoulder",
        left_wrist: "left_elbow",
        right_wrist: "right_elbow",
        left_knee: "left_hip",
        right_knee: "right_hip",
        left_ankle: "left_knee",
        right_ankle: "right_knee",
      };

      // 定义肢体名称
      const LIMB_NAMES = {
        left_elbow: "左上臂",
        right_elbow: "右上臂",
        left_wrist: "左前臂",
        right_wrist: "右前臂",
        left_knee: "左大腿",
        right_knee: "右大腿",
        left_ankle: "左小腿",
        right_ankle: "右小腿",
      };

      // 关键点颜色
      const KEYPOINT_COLORS = {
        left_shoulder: "#ff0000", // 红色
        right_shoulder: "#00ff00", // 绿色
        left_elbow: "#ff00ff", // 品红
        right_elbow: "#ffff00", // 黄色
        left_wrist: "#00ffff", // 青色
        right_wrist: "#ffa500", // 橙色
        left_hip: "#800080", // 紫色
        right_hip: "#008000", // 深绿色
        left_knee: "#0000ff", // 蓝色
        right_knee: "#ffc0cb", // 粉色
        left_ankle: "#a52a2a", // 棕色
        right_ankle: "#808080", // 灰色
      };

      // 时间格式化函数
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, "0")}:${secs
          .toString()
          .padStart(2, "0")}`;
      }

      // 计算两点之间的角度
      function calculateAngle(parentPoint, childPoint) {
        if (!parentPoint || !childPoint) return null;

        const deltaX = childPoint.x - parentPoint.x;
        const deltaY = childPoint.y - parentPoint.y;

        // 计算角度（以父节点为原点，计算子节点相对于父节点的角度）
        let angle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;

        // 确保角度在0-360范围内
        if (angle < 0) {
          angle += 360;
        }

        return angle;
      }

      // 计算所有关键点相对于父节点的角度
      function calculateAllAngles(keypoints) {
        const angles = {};

        // 创建一个关键点映射，方便查找
        const keypointsMap = {};
        keypoints.forEach((kp) => {
          keypointsMap[kp.name] = kp;
        });

        // 计算每个关键点相对于父节点的角度
        for (const [keypointName, parentName] of Object.entries(
          KEYPOINT_PARENTS
        )) {
          // 跳过根节点（没有父节点的关键点）
          if (parentName === null) {
            angles[keypointName] = null;
            continue;
          }

          const keypoint = keypointsMap[keypointName];
          const parentPoint = keypointsMap[parentName];

          // 只计算置信度大于0.2的关键点
          if (
            keypoint &&
            parentPoint &&
            keypoint.score >= 0.2 &&
            parentPoint.score >= 0.2
          ) {
            angles[keypointName] = calculateAngle(parentPoint, keypoint);
          } else {
            angles[keypointName] = null;
          }
        }

        return angles;
      }

      // 在canvas上绘制关键点和连线
      function drawKeypoints(ctx, keypoints, angles, frameBuffer) {
        // 创建一个关键点映射，方便查找
        const keypointsMap = {};
        keypoints.forEach((kp) => {
          keypointsMap[kp.name] = kp;
        });

        // 绘制连接线
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;

        // 绘制骨架连接线
        const connections = [
          ["left_shoulder", "right_shoulder"],
          ["left_shoulder", "left_hip"],
          ["right_shoulder", "right_hip"],
          ["left_shoulder", "left_elbow"],
          ["right_shoulder", "right_elbow"],
          ["left_elbow", "left_wrist"],
          ["right_elbow", "right_wrist"],
          ["left_hip", "right_hip"],
          ["left_hip", "left_knee"],
          ["right_hip", "right_knee"],
          ["left_knee", "left_ankle"],
          ["right_knee", "right_ankle"],
        ];

        connections.forEach(([start, end]) => {
          const startPoint = keypointsMap[start];
          const endPoint = keypointsMap[end];

          if (
            startPoint &&
            endPoint &&
            startPoint.score >= 0.2 &&
            endPoint.score >= 0.2
          ) {
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
          }
        });

        // 绘制关键点和角度
        for (const keypointName in KEYPOINT_PARENTS) {
          const keypoint = keypointsMap[keypointName];
          const parentName = KEYPOINT_PARENTS[keypointName];
          const parentPoint = parentName ? keypointsMap[parentName] : null;

          if (keypoint && keypoint.score >= 0.2) {
            // 绘制关键点
            ctx.fillStyle = KEYPOINT_COLORS[keypointName] || "#ffffff";
            ctx.beginPath();
            ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      }

      // 绘制1秒内的运动轨迹
      function drawTrajectory(ctx, frameBuffer, keypointNames) {
        // 只绘制指定的关键点轨迹
        keypointNames.forEach((keypointName) => {
          const trajectoryPoints = [];

          // 收集1秒内的轨迹点
          frameBuffer.forEach((frame) => {
            const keypoint = frame.keypoints.find(
              (kp) => kp.name === keypointName
            );
            if (keypoint && keypoint.score >= 0.2) {
              trajectoryPoints.push(keypoint);
            }
          });

          // 绘制轨迹线（使用贝塞尔曲线）
          if (trajectoryPoints.length > 1) {
            ctx.strokeStyle = KEYPOINT_COLORS[keypointName] || "#ffffff";
            ctx.lineWidth = 3;
            ctx.beginPath();

            // 如果只有两个点，绘制直线
            if (trajectoryPoints.length === 2) {
              ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
              ctx.lineTo(trajectoryPoints[1].x, trajectoryPoints[1].y);
            }
            // 如果有三个或更多点，使用贝塞尔曲线
            else if (trajectoryPoints.length >= 3) {
              ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);

              // 对于中间的点，使用贝塞尔曲线连接
              for (let i = 1; i < trajectoryPoints.length - 1; i++) {
                const xc =
                  (trajectoryPoints[i].x + trajectoryPoints[i + 1].x) / 2;
                const yc =
                  (trajectoryPoints[i].y + trajectoryPoints[i + 1].y) / 2;
                ctx.quadraticCurveTo(
                  trajectoryPoints[i].x,
                  trajectoryPoints[i].y,
                  xc,
                  yc
                );
              }

              // 连接到最后一个点
              ctx.quadraticCurveTo(
                trajectoryPoints[trajectoryPoints.length - 1].x,
                trajectoryPoints[trajectoryPoints.length - 1].y,
                trajectoryPoints[trajectoryPoints.length - 1].x,
                trajectoryPoints[trajectoryPoints.length - 1].y
              );
            }

            ctx.stroke();
          }
        });
      }

      // 显示角度数据
      function displayAngleData(angleData, container) {
        let html = "";

        for (const [keypointName, angle] of Object.entries(angleData)) {
          if (angle !== null && angle !== undefined) {
            html += `<div class="angle-item">${keypointName}: ${angle.toFixed(
              2
            )}°</div>`;
          } else {
            html += `<div class="angle-item">${keypointName}: 无法计算</div>`;
          }
        }

        container.innerHTML = html;
      }

      // // 显示各肢体相似度
      // function displayLimbSimilarity(referenceAngles, targetAngles) {
      //     // 添加容错处理

      //     let html = '';

      //     for (const [keypointName, limbName] of Object.entries(LIMB_NAMES)) {
      //         // 添加容错处理
      //                     if (!referenceAngles || !targetAngles) {
      //         limbSimilarityData.innerHTML = '<div class="error-message">数据不可用</div>';
      //         return;
      //     }
      //         if (!referenceAngles.hasOwnProperty(keypointName) || !targetAngles.hasOwnProperty(keypointName)) {
      //             html += `<div class="limb-similarity-item">
      //                 <span class="limb-name">${limbName}:</span>
      //                 <span class="limb-similarity-value">数据缺失</span>
      //             </div>`;
      //             continue;
      //         }

      //         const refAngle = referenceAngles[keypointName];
      //         const targetAngle = targetAngles[keypointName];
      //         if (refAngle !== null && refAngle !== undefined &&
      //             targetAngle !== null && targetAngle !== undefined) {
      //             // 计算角度差值（考虑角度循环特性）
      //             let diff = Math.abs(refAngle - targetAngle);
      //             if (diff > 180) {
      //                 diff = 360 - diff;
      //             }

      //             // 将差异转换为相似度百分比
      //             const similarity = Math.max(0, 100 - diff);
      //             html += `<div class="limb-similarity-item">
      //                 <span class="limb-name">${limbName}:</span>
      //                 <span class="limb-similarity-value">${similarity.toFixed(1)}%</span>
      //             </div>`;
      //         } else {
      //             html += `<div class="limb-similarity-item">
      //                 <span class="limb-name">${limbName}:</span>
      //                 <span class="limb-similarity-value">无法计算</span>
      //             </div>`;
      //         }
      //     }

      //     limbSimilarityData.innerHTML = html;
      // }

      // 比较两个角度数据的相似度
      function compareAngles(referenceAngles, targetAngles) {
        // 添加容错处理
        if (!referenceAngles || !targetAngles) {
          return {
            similarity: 0,
            averageDifference: 0,
            validCount: 0,
          };
        }

        let totalDifference = 0;
        let validCount = 0;

        // 计算参考视频和目标视频的平均肩膀距离
        let refShoulderDistances = referenceFrameBuffer
          .map((frame) => frame.shoulderDistance)
          .filter((dist) => dist > 0);

        let targetShoulderDistances = targetFrameBuffer
          .map((frame) => frame.shoulderDistance)
          .filter((dist) => dist > 0);

        let avgRefShoulderDistance = 0;
        let avgTargetShoulderDistance = 0;

        if (refShoulderDistances.length > 0) {
          const refSum = refShoulderDistances.reduce(
            (acc, val) => acc + val,
            0
          );
          avgRefShoulderDistance = refSum / refShoulderDistances.length;
        }

        if (targetShoulderDistances.length > 0) {
          const targetSum = targetShoulderDistances.reduce(
            (acc, val) => acc + val,
            0
          );
          avgTargetShoulderDistance =
            targetSum / targetShoulderDistances.length;
        }

        // 比较关键点角度
        for (const keypointName in referenceAngles) {
          // 添加容错处理
          if (
            !referenceAngles.hasOwnProperty(keypointName) ||
            !targetAngles.hasOwnProperty(keypointName)
          ) {
            continue;
          }

          const refAngle = referenceAngles[keypointName];
          const targetAngle = targetAngles[keypointName];

          // 只有当两个角度都有效时才进行比较
          if (
            refAngle !== null &&
            refAngle !== undefined &&
            targetAngle !== null &&
            targetAngle !== undefined
          ) {
            // 计算角度差值（考虑角度循环特性）
            let diff = Math.abs(refAngle - targetAngle);
            if (diff > 180) {
              diff = 360 - diff;
            }
            // 如果角度差值小于30度，则认为角度相同
            if (diff < 30) {
              diff = 0;
            }

            // 特殊处理：如果平均肩膀距离有效，并且当前关键点是手腕或脚踝
            if (
              avgRefShoulderDistance > 0 &&
              avgTargetShoulderDistance > 0 &&
              (keypointName.includes("wrist") ||
                keypointName.includes("ankle")) &&
              referenceFrameBuffer.length > 0 &&
              targetFrameBuffer.length > 0
            ) {
              const refFrame =
                referenceFrameBuffer[referenceFrameBuffer.length - 1];
              const targetFrame =
                targetFrameBuffer[targetFrameBuffer.length - 1];

              if (refFrame.keypoints && targetFrame.keypoints) {
                const refKeypoint = refFrame.keypoints.find(
                  (kp) => kp.name === keypointName
                );
                const targetKeypoint = targetFrame.keypoints.find(
                  (kp) => kp.name === keypointName
                );

                // 检查关键点置信度
                if (
                  refKeypoint &&
                  targetKeypoint &&
                  refKeypoint.score >= 0.2 &&
                  targetKeypoint.score >= 0.2
                ) {
                  // 计算当前关键点之间的距离
                  const keypointDistance = Math.hypot(
                    refKeypoint.x - targetKeypoint.x,
                    refKeypoint.y - targetKeypoint.y
                  );

                  // 分别检查与参考视频和目标视频的肩膀距离关系
                  if (
                    keypointDistance < avgRefShoulderDistance / 2 ||
                    keypointDistance < avgTargetShoulderDistance / 2
                  ) {
                    diff = 0;
                  }
                }
              }
            }

            totalDifference += diff;
            validCount++;
          }
        }

        // 计算平均差异
        const averageDifference =
          validCount > 0 ? totalDifference / validCount : 0;

        // 将差异转换为相似度百分比（差异越小，相似度越高）
        const similarity = Math.max(0, 100 - totalDifference);

        return {
          similarity: similarity,
          averageDifference: averageDifference,
          validCount: validCount,
        };
      }

      // 计算上半身相似度
      function calculateUpperBodySimilarity(referenceAngles, targetAngles) {
        if (!referenceAngles || !targetAngles) {
          return 0;
        }

        const upperBodyLimbs = [
          "left_elbow",
          "right_elbow",
          "left_wrist",
          "right_wrist",
        ];
        let totalDifference = 0;
        let validCount = 0;

        for (const limb of upperBodyLimbs) {
          const refAngle = referenceAngles[limb];
          const targetAngle = targetAngles[limb];

          if (
            refAngle !== null &&
            refAngle !== undefined &&
            targetAngle !== null &&
            targetAngle !== undefined
          ) {
            let diff = Math.abs(refAngle - targetAngle);
            if (diff > 180) {
              diff = 360 - diff;
            }

            totalDifference += diff;
            validCount++;
          }
        }

        // 计算上半身相似度
        const similarity =
          validCount > 0 ? Math.max(0, 100 - totalDifference) : 0;
        return similarity;
      }

      // 计算下半身相似度
      function calculateLowerBodySimilarity(referenceAngles, targetAngles) {
        if (!referenceAngles || !targetAngles) {
          return 0;
        }

        const lowerBodyLimbs = [
          "left_knee",
          "right_knee",
          "left_ankle",
          "right_ankle",
        ];
        let totalDifference = 0;
        let validCount = 0;

        for (const limb of lowerBodyLimbs) {
          const refAngle = referenceAngles[limb];
          const targetAngle = targetAngles[limb];

          if (
            refAngle !== null &&
            refAngle !== undefined &&
            targetAngle !== null &&
            targetAngle !== undefined
          ) {
            let diff = Math.abs(refAngle - targetAngle);
            if (diff > 180) {
              diff = 360 - diff;
            }

            totalDifference += diff;
            validCount++;
          }
        }

        // 计算下半身相似度
        const similarity =
          validCount > 0 ? Math.max(0, 100 - totalDifference) : 0;
        return similarity;
      }

      // 比较一秒内所有帧的角度，返回最高相似度
      function compareBufferFrames(referenceBuffer, targetBuffer) {
        let maxSimilarity = 0;
        let bestComparison = null;
        let bestReferenceAngles = null;
        let bestTargetAngles = null;

        // 比较每一帧
        for (const refFrame of referenceBuffer) {
          for (const targetFrame of targetBuffer) {
            if (refFrame.angles && targetFrame.angles) {
              const comparisonResult = compareAngles(
                refFrame.angles,
                targetFrame.angles
              );
              if (comparisonResult.similarity > maxSimilarity) {
                maxSimilarity = comparisonResult.similarity;
                bestComparison = comparisonResult;
                bestReferenceAngles = refFrame.angles;
                bestTargetAngles = targetFrame.angles;
              }
            }
          }
        }

        // displayLimbSimilarity(bestReferenceAngles, bestTargetAngles);
        return {
          similarity: maxSimilarity,
          comparison: bestComparison,
          referenceAngles: bestReferenceAngles,
          targetAngles: bestTargetAngles,
        };
      }

      // 加载MoveNet模型
      async function loadMoveNetModel() {
        try {
          // 创建参考视频的姿态检测器
          referencePoseDetector = await poseDetection.createDetector(
            poseDetection.SupportedModels.MoveNet,
            {
              modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
              enableSmoothing: true,
              modelUrl: "./models/model.json",
            }
          );

          // 创建对比视频的姿态检测器
          targetPoseDetector = await poseDetection.createDetector(
            poseDetection.SupportedModels.MoveNet,
            {
              modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
              enableSmoothing: true,
              modelUrl: "./models/model.json",
            }
          );

          console.log("MoveNet模型加载完成");
        } catch (error) {
          console.error("加载MoveNet模型失败:", error);
        }
      }

      // 检测姿态
      async function detectPose(video, canvas, ctx, poseDetector) {
        if (!poseDetector) return [];

        try {
          // 使用MoveNet检测姿态
          const poses = await poseDetector.estimatePoses(video, {
            maxPoses: 1,
            flipHorizontal: false,
          });

          if (poses && poses.length > 0) {
            return poses[0].keypoints;
          }
        } catch (error) {
          console.error("姿态检测出错:", error);
        }

        return [];
      }

      // 加载参考视频
      loadReferenceButton.addEventListener("click", () => {
        if (referenceFileInput.files.length > 0) {
          const file = referenceFileInput.files[0];
          const url = URL.createObjectURL(file);
          referenceVideo.src = url;
        }
      });

      // 加载对比视频
      loadTargetButton.addEventListener("click", () => {
        // 如果正在使用摄像头，先停止摄像头
        if (cameraStream) {
          stopCamera();
        }

        if (targetFileInput.files.length > 0) {
          const file = targetFileInput.files[0];
          const url = URL.createObjectURL(file);
          targetVideo.src = url;
        }
      });

      // 对比视频加载完成事件
      targetVideo.addEventListener("loadeddata", () => {
        targetLoaded = true;
        targetCanvas.width = targetVideo.videoWidth;
        targetCanvas.height = targetVideo.videoHeight;
        targetTotalTime.textContent = formatTime(targetVideo.duration);
        targetPlayButton.disabled = false;
        // targetAnalyzeButton.disabled = false;
        if (referenceLoaded) {
          startComparisonButton.disabled = false;
        }
      });

      // 使用摄像头
      useCameraButton.addEventListener("click", async () => {
        try {
          // 如果正在播放视频，先停止播放
          targetVideo.pause();

          // 获取摄像头流
          cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: "user",
            },
            audio: false,
          });

          // 设置视频源为摄像头流
          targetVideo.srcObject = cameraStream;
          targetVideo.play();

          // 更新按钮状态
          useCameraButton.disabled = false;
          stopCameraButton.disabled = false;
          targetPlayButton.disabled = false;
          targetPauseButton.disabled = false;
          targetAnalyzeButton.disabled = false;
          targetLoaded = true;

          // 设置画布尺寸
          targetVideo.addEventListener(
            "loadedmetadata",
            () => {
              targetCanvas.width = targetVideo.videoWidth;
              targetCanvas.height = targetVideo.videoHeight;
              targetTotalTime.textContent = "Live";
            },
            { once: true }
          );

          // 启用开始比较按钮（如果参考视频已加载）
          if (referenceLoaded) {
            startComparisonButton.disabled = false;
          }
        } catch (err) {
          console.error("无法访问摄像头:", err);
        }
      });

      // 停止摄像头
      function stopCamera() {
        if (cameraStream) {
          const tracks = cameraStream.getTracks();
          tracks.forEach((track) => track.stop());
          cameraStream = null;
          targetVideo.srcObject = null;

          // 更新按钮状态
          useCameraButton.disabled = false;
          stopCameraButton.disabled = false;
          targetAnalyzeButton.disabled = false;
          targetLoaded = false;

          // 禁用开始比较按钮
          if (!targetFileInput.files.length) {
            startComparisonButton.disabled = false;
          }
        }
      }

      // 停止摄像头按钮事件
      stopCameraButton.addEventListener("click", stopCamera);

      // 参考视频加载完成事件
      referenceVideo.addEventListener("loadedmetadata", () => {
        referenceLoaded = true;
        referenceCanvas.width = referenceVideo.videoWidth;
        referenceCanvas.height = referenceVideo.videoHeight;
        referenceTotalTime.textContent = formatTime(referenceVideo.duration);
        referencePlayButton.disabled = false;
        referenceAnalyzeButton.disabled = false;
        if (targetLoaded) {
          startComparisonButton.disabled = false;
        }
      });

      // 对比视频加载完成事件
      targetVideo.addEventListener("loadedmetadata", () => {
        targetLoaded = true;
        targetCanvas.width = targetVideo.videoWidth;
        targetCanvas.height = targetVideo.videoHeight;
        targetTotalTime.textContent = formatTime(targetVideo.duration);
        targetPlayButton.disabled = false;
        targetAnalyzeButton.disabled = false;
        if (referenceLoaded) {
          startComparisonButton.disabled = false;
        }
      });

      // 参考视频播放按钮
      referencePlayButton.addEventListener("click", () => {
        referenceVideo.play();
      });

      // 参考视频暂停按钮
      referencePauseButton.addEventListener("click", () => {
        referenceVideo.pause();
      });

      // 对比视频播放按钮
      targetPlayButton.addEventListener("click", () => {
        targetVideo.play();
      });

      // 对比视频暂停按钮
      targetPauseButton.addEventListener("click", () => {
        targetVideo.pause();
      });

      // 参考视频播放事件
      referenceVideo.addEventListener("play", () => {
        referencePlayButton.disabled = false;
        referencePauseButton.disabled = false;
      });

      // 参考视频暂停事件
      referenceVideo.addEventListener("pause", () => {
        referencePlayButton.disabled = false;
        referencePauseButton.disabled = false;
      });

      // 对比视频播放事件
      targetVideo.addEventListener("play", () => {
        targetPlayButton.disabled = false;
        targetPauseButton.disabled = false;
      });

      // 对比视频暂停事件
      targetVideo.addEventListener("pause", () => {
        targetPlayButton.disabled = false;
        targetPauseButton.disabled = false;
      });

      // 参考视频时间更新
      referenceVideo.addEventListener("timeupdate", () => {
        const currentTime = referenceVideo.currentTime;
        const duration = referenceVideo.duration;
        referenceCurrentTime.textContent = formatTime(currentTime);
        referenceProgressBar.value = (currentTime / duration) * 100;
      });

      // 对比视频时间更新
      targetVideo.addEventListener("timeupdate", () => {
        // 如果正在使用摄像头，不更新进度条
        if (cameraStream) {
          targetCurrentTime.textContent = "Live";
          targetProgressBar.value = 0;
          return;
        }

        const currentTime = targetVideo.currentTime;
        const duration = targetVideo.duration;
        targetCurrentTime.textContent = formatTime(currentTime);
        targetProgressBar.value = (currentTime / duration) * 100;
      });

      // 参考视频进度条拖动
      referenceProgressBar.addEventListener("input", () => {
        const duration = referenceVideo.duration;
        const newTime = (referenceProgressBar.value / 100) * duration;
        referenceVideo.currentTime = newTime;
      });

      // 对比视频进度条拖动
      targetProgressBar.addEventListener("input", () => {
        const duration = targetVideo.duration;
        const newTime = (targetProgressBar.value / 100) * duration;
        targetVideo.currentTime = newTime;
      });

      // 开始比较按钮
      startComparisonButton.addEventListener("click", async () => {
        if (!referenceLoaded || !targetLoaded) return;

        // 如果模型尚未加载，先加载模型
        if (!referencePoseDetector || !targetPoseDetector) {
          similarityStatus.textContent = "正在加载模型...";
          await loadMoveNetModel();
        }

        comparisonRunning = true;
        startComparisonButton.disabled = false;
        stopComparisonButton.disabled = false;
        similarityStatus.textContent = "正在比较中...";

        // 清空帧缓存
        referenceFrameBuffer = [];
        targetFrameBuffer = [];
        currentSecond = -1;

        // 清空上一次角度缓存
        lastReferenceAngles = {};
        lastTargetAngles = {};

        // 同步播放两个视频

        referenceVideo.play();
        targetVideo.play();

        // 开始相似度分析
        startSimilarityAnalysis();
      });

      // 停止比较按钮
      stopComparisonButton.addEventListener("click", () => {
        comparisonRunning = false;
        startComparisonButton.disabled = false;
        stopComparisonButton.disabled = false;
        referenceVideo.pause();
        targetVideo.pause();
        similarityStatus.textContent = "比较已停止";

        // 如果正在使用摄像头，停止摄像头
        if (cameraStream) {
          stopCamera();
        }
      });

      // 相似度分析
      async function startSimilarityAnalysis() {
        if (!comparisonRunning) return;

        // 获取当前秒数
        const refSecond = Math.floor(referenceVideo.currentTime);
        const targetSecond = Math.floor(targetVideo.currentTime);

        currentSecond = refSecond;

        // 清除画布
        referenceCtx.clearRect(
          0,
          0,
          referenceCanvas.width,
          referenceCanvas.height
        );
        targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);

        // 绘制视频帧
        referenceCtx.drawImage(
          referenceVideo,
          0,
          0,
          referenceCanvas.width,
          referenceCanvas.height
        );
        targetCtx.drawImage(
          targetVideo,
          0,
          0,
          targetCanvas.width,
          targetCanvas.height
        );

        // 检测姿态
        const referenceKeypoints = await detectPose(
          referenceVideo,
          referenceCanvas,
          referenceCtx,
          referencePoseDetector
        );
        const targetKeypoints = await detectPose(
          targetVideo,
          targetCanvas,
          targetCtx,
          targetPoseDetector
        );

        if (referenceKeypoints.length > 0 && targetKeypoints.length > 0) {
          // 计算角度
          let referenceAngles = calculateAllAngles(referenceKeypoints);
          let targetAngles = calculateAllAngles(targetKeypoints);

          // 处理角度丢失的情况，使用上一次的角度
          for (const keypointName in KEYPOINT_PARENTS) {
            if (
              referenceAngles[keypointName] === null &&
              lastReferenceAngles[keypointName] !== undefined
            ) {
              referenceAngles[keypointName] = lastReferenceAngles[keypointName];
            } else if (referenceAngles[keypointName] !== null) {
              lastReferenceAngles[keypointName] = referenceAngles[keypointName];
            }

            if (
              targetAngles[keypointName] === null &&
              lastTargetAngles[keypointName] !== undefined
            ) {
              targetAngles[keypointName] = lastTargetAngles[keypointName];
            } else if (targetAngles[keypointName] !== null) {
              lastTargetAngles[keypointName] = targetAngles[keypointName];
            }
          }

          // 将帧数据添加到缓存中
          // 处理参考视频关键点置信度不足的情况
          // 为置信度不足的关键点使用上一次的值
          const processedRefKeypoints = referenceKeypoints.map((kp) => {
            // 如果当前关键点置信度不足，且存在上一次的记录，则使用上一次的值
            if (kp.score < 0.2 && lastReferenceKeypoints[kp.name]) {
              return lastReferenceKeypoints[kp.name];
            }
            return kp;
          });

          // 更新上一次关键点缓存（只记录置信度>0.2的点）
          referenceKeypoints.forEach((kp) => {
            if (kp.score > 0.2) {
              lastReferenceKeypoints[kp.name] = kp;
            }
          });

          // 计算参考视频肩膀距离
          let refShoulderDistance = 0;
          const refLeftShoulder = processedRefKeypoints.find(
            (kp) => kp.name === "left_shoulder"
          );
          const refRightShoulder = processedRefKeypoints.find(
            (kp) => kp.name === "right_shoulder"
          );

          if (
            refLeftShoulder &&
            refRightShoulder &&
            refLeftShoulder.score >= 0.2 &&
            refRightShoulder.score >= 0.2
          ) {
            refShoulderDistance = Math.hypot(
              refLeftShoulder.x - refRightShoulder.x,
              refLeftShoulder.y - refRightShoulder.y
            );
          }

          referenceFrameBuffer.push({
            time: referenceVideo.currentTime,
            keypoints: processedRefKeypoints,
            angles: referenceAngles,
            shoulderDistance: refShoulderDistance,
          });

          // 处理目标视频关键点置信度不足的情况
          // 为置信度不足的关键点使用上一次的值
          const processedTargetKeypoints = targetKeypoints.map((kp) => {
            // 如果当前关键点置信度不足，且存在上一次的记录，则使用上一次的值
            if (kp.score < 0.2 && lastTargetKeypoints[kp.name]) {
              return lastTargetKeypoints[kp.name];
            }
            return kp;
          });

          // 更新上一次关键点缓存（只记录置信度>0.2的点）
          targetKeypoints.forEach((kp) => {
            if (kp.score > 0.2) {
              lastTargetKeypoints[kp.name] = kp;
            }
          });

          // 计算目标视频肩膀距离
          let targetShoulderDistance = 0;
          const targetLeftShoulder = processedTargetKeypoints.find(
            (kp) => kp.name === "left_shoulder"
          );
          const targetRightShoulder = processedTargetKeypoints.find(
            (kp) => kp.name === "right_shoulder"
          );

          if (
            targetLeftShoulder &&
            targetRightShoulder &&
            targetLeftShoulder.score >= 0.2 &&
            targetRightShoulder.score >= 0.2
          ) {
            targetShoulderDistance = Math.hypot(
              targetLeftShoulder.x - targetRightShoulder.x,
              targetLeftShoulder.y - targetRightShoulder.y
            );
          }

          targetFrameBuffer.push({
            time: targetVideo.currentTime,
            keypoints: processedTargetKeypoints,
            angles: targetAngles,
            shoulderDistance: targetShoulderDistance,
          });

          // 维持滑动窗口大小
          if (referenceFrameBuffer.length > WINDOW_SIZE) {
            referenceFrameBuffer.shift();
          }

          if (targetFrameBuffer.length > WINDOW_SIZE) {
            targetFrameBuffer.shift();
          }

          // 当缓冲区足够时，进行滑动窗口比较

          const windowComparison = compareBufferFrames(
            referenceFrameBuffer,
            targetFrameBuffer
          );

          if (windowComparison.similarity) {
            // 显示 相似度
            const similarity = Math.floor(windowComparison.similarity);

            // 显示窗口相似度
            windowSimilarity.textContent = `${similarity}%`;

            // 计算并显示上半身和下半身瞬间相似度
            if (
              windowComparison.referenceAngles &&
              windowComparison.targetAngles
            ) {
              const upperBodySim = Math.floor(
                calculateUpperBodySimilarity(
                  windowComparison.referenceAngles,
                  windowComparison.targetAngles
                )
              );
              const lowerBodySim = Math.floor(
                calculateLowerBodySimilarity(
                  windowComparison.referenceAngles,
                  windowComparison.targetAngles
                )
              );

              upperBodyInstantSimilarity.textContent = `${upperBodySim}%`;
              lowerBodyInstantSimilarity.textContent = `${lowerBodySim}%`;
            }

            // 显示角度差异对比
            const comparisonResult = windowComparison.comparison;
            if (comparisonResult) {
              comparisonAngleData.innerHTML = `
                                <div class="angle-item">有效关键点数: ${
                                  comparisonResult.validCount
                                }</div>
                                <div class="angle-item">平均角度差异: ${comparisonResult.averageDifference.toFixed(
                                  2
                                )}°</div>
                                <div class="angle-item">最高相似度: ${similarity}%</div>
                            `;
            }
          }

          // 在canvas上绘制关键点和角度
          drawKeypoints(referenceCtx, referenceKeypoints, referenceAngles);
          drawKeypoints(targetCtx, targetKeypoints, targetAngles);

          // 绘制1秒内的轨迹（只在参考视频中绘制ankle和wrist的轨迹）
          drawTrajectory(referenceCtx, referenceFrameBuffer, [
            "left_ankle",
            "right_ankle",
            "left_wrist",
            "right_wrist",
          ]);

          // 显示角度数据
          displayAngleData(referenceAngles, referenceAngleData);
          displayAngleData(targetAngles, targetAngleData);

          // 更新对比数据
          comparisonData.innerHTML = `
                    <p>参考视频时间: ${formatTime(
                      referenceVideo.currentTime
                    )}</p>
                    <p>对比视频时间: ${formatTime(targetVideo.currentTime)}</p>
                    <p>参考视频检测到关键点数量: ${
                      referenceKeypoints.filter((kp) => kp.score >= 0.2).length
                    }</p>
                    <p>对比视频检测到关键点数量: ${
                      targetKeypoints.filter((kp) => kp.score >= 0.2).length
                    }</p>
                    <p>参考视频缓存帧数: ${referenceFrameBuffer.length}</p>
                    <p>对比视频缓存帧数: ${targetFrameBuffer.length}</p>
                `;
        } else {
          // 如果没有检测到关键点，显示提示信息
          referenceAngleData.innerHTML = "未检测到姿态";
          targetAngleData.innerHTML = "未检测到姿态";
        }

        // 继续下一帧分析
        setTimeout(startSimilarityAnalysis, 10);
      }

      // 页面加载完成初始化
      document.addEventListener("DOMContentLoaded", () => {
        // 初始化按钮状态
        referencePlayButton.disabled = false;
        referencePauseButton.disabled = false;
        referenceAnalyzeButton.disabled = false;

        targetPlayButton.disabled = false;
        targetPauseButton.disabled = false;
        targetAnalyzeButton.disabled = false;

        startComparisonButton.disabled = false;
        stopComparisonButton.disabled = false;

        // 向参考视频和对比视频容器添加轨迹提示
        const referenceWrapper =
          document.querySelector("#referenceCanvas").parentElement;
        if (referenceWrapper) {
          referenceWrapper.appendChild(trajectoryHint.cloneNode(true));
        }

        const targetWrapper =
          document.querySelector("#targetCanvas").parentElement;
        if (targetWrapper) {
          const targetHint = trajectoryHint.cloneNode(true);
          targetWrapper.appendChild(targetHint);
        }
      });
    </script>
  </body>
</html>
